# Análisis de Algoritmos: Eficiencia y Optimización 🚀

![Python Logo](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)

Esta investigación aborda el **análisis de la eficiencia algorítmica**, 
explorando conceptos como la complejidad temporal y espacial a través de la comparación de algoritmos de ordenamiento como **Bubble Sort** y **Merge Sort**.

---

## Alumnas:
- Giselle Chaumont Mohr 
- Daiana Ghisio 

## Materia: Programación I 

---


## Links importantes
- [Presentación completa](https://www.canva.com/design/DAGpzNIN9kw/Hi_Bu2Lj6mKubDnLleG93A/view?utm_content=DAGpzNIN9kw&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h7912061800)
- 
- [Video completo](https://youtu.be/Z1uCNgTEqL8)



## Descripción del Proyecto

Este Trabajo Práctico Integrador de Programación I se centra en la **eficiencia algorítmica**, un pilar fundamental en el desarrollo de software. 
El proyecto busca demostrar cómo diferentes algoritmos utilizan los recursos computacionales, específicamente el tiempo de ejecución y la memoria.

---

## Caso Práctico

El proyecto incluye una implementación en Python de los algoritmos **Bubble Sort** y **Merge Sort**, y una función para comparar su rendimiento temporal.

## Tecnología utilizada
- Lenguaje: Python

## Instalación y Uso

### Requisitos Previos

Asegúrate de tener instalado **Python** en tu sistema (versión 3.x recomendada).

### Pasos para la Instalación

1.  **Clonar el repositorio:**
    ```bash
    git clone https://github.com/daianaghisio/TP-Programacion-I.git
    ```
2.  **Acceder al directorio del proyecto:**
    ```bash
    cd TP-Programacion-I
    ```

### Ejecución del Proyecto

Para ejecutar el script y ver la comparación de tiempos, navega al directorio del proyecto en tu terminal y ejecuta:

```bash
python Comparacion_Algoritmos.py
  ```

## Reflexiones sobre los aprendizajes obtenidos

-  A través del caso práctico, pudimos comprobar que Merge Sort, aunque más complejo, resulta mucho más eficiente que Bubble Sort al trabajar con listas grandes, tal como sugería nuestra investigación teórica.

- Nos dimos cuenta de que no se trata solo de que el código funcione, sino de que funcione de manera eficiente.

- Aprendimos que la optimización no es solo "hacerlo más rápido", sino encontrar el balance adecuado entre tiempo y memoria según los requerimientos del problema que estemos resolviendo.


## Licencia

Este proyecto es de carácter académico y se distribuye con fines educativos.



